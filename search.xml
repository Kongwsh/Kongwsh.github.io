<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计学习笔记（二）继承模式]]></title>
      <url>http://yoursite.com/2016/08/25/javascript-3/</url>
      <content type="html"><![CDATA[<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>JavaScript的继承主要依靠原型链来实现的。我们知道，构造函数，原型，和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<a id="more"></a>
<p>实现原型链的方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function  SuperType()&#123;</div><div class="line">    this.property=true;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue=function()&#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function  SubType()&#123;</div><div class="line">    this.subpropertype=false;</div><div class="line">&#125;</div><div class="line">//让原型对象称为另一个构造函数的实例</div><div class="line">SubType.prototype=new SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue=function()&#123;</div><div class="line">    return this.subpropertype;</div><div class="line">&#125;;</div><div class="line">var  instance=new SubType();</div><div class="line">alert(instance.getSuperValue());//true</div><div class="line">//？这个实例继承了SuperType.prototype的constructor属性？</div><div class="line">alert(instance.constructor==SuperType);//true</div></pre></td></tr></table></figure></p>
<p>上述代码继承是通过<code>SubType.prototype=new SuperType();</code>来实现，创建<code>SuperType</code>的实例，并将该实例赋给<code>SubType.prototype</code>。</p>
<p><strong>继承实现的本质是重写原型对象，代之以一个新类型的实例。</strong></p>
<p>下图为构造函数，实例以及原型之间的关系图：<br><img src="/images/Inheritance.jpg" title="继承"></p>
<blockquote>
<p>原型链顶端:所有引用类型都默认继承Object，所以，所有函数的默认原型都是Object的实例，默认原型都会包含一个内部指针[[prototype]]，指向Object.prototype。</p>
</blockquote>
<h2 id="原型链缺点"><a href="#原型链缺点" class="headerlink" title="原型链缺点"></a>原型链缺点</h2><ol>
<li>实例属性变为原型属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function  SuperType()&#123;</div><div class="line">    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</div><div class="line">&#125;</div><div class="line">function  SubType()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.color.push(&quot;black&quot;);</div><div class="line">alert(instance1.color);//&quot;red,green,blue,black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.color);//&quot;red,green,blue,black&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个问题似曾相识，正是原型模式创建对象时由于共享引用类型属性，导致牵一发动全身的问题。</p>
<ol>
<li>在创建子类型时，不能向超类型的构造函数传递参数。</li>
</ol>
<p>所以，单独使用原型链情况较少。</p>
<h1 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h1><p>针对原型链的第一个问题，我们可采用借用构造函数的技术来解决。基本思想就是在子类型构造函数的内部调用超类型构造函数。看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function  SuperType()&#123;</div><div class="line">    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</div><div class="line">&#125;</div><div class="line">function  SubType()&#123;</div><div class="line">    //继承自SuperType</div><div class="line">    SuperType.call(this);</div><div class="line">&#125;</div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.color.push(&quot;black&quot;);</div><div class="line">alert(instance1.color);//&quot;red,green,blue,black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.color);//&quot;red,green,blue&quot;</div></pre></td></tr></table></figure></p>
<p>在新创建的SubType子类型的实例中调用SuperType超类型构造函数，就可以在新的实例对象上执行SuperType()函数中定义的所有对象初始化代码。问题不就解决了吗！<br><strong>但是</strong>，这种模式的缺点是在超类型中定义的方法，对子类型是不可见的，无法实现共享方法。<br>所以，这种方法也不常用。</p>
<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。无疑，集两者之大成，这才是最常用的继承模式。看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function  SuperType()&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div><div class="line">function  SubType(name,age)&#123;</div><div class="line">    //继承了SuperType</div><div class="line">    SuperType.call(this,name);</div><div class="line">    //自己又添加了一个</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">//构建原型链</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">//重写SubType.prototype的constructor属性，指向自己的构造函数SubType</div><div class="line">SubType.prototype.constructor=SubType;</div><div class="line">//原型方法，被实例们共享</div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Nichola&quot;,29);</div><div class="line">instance1.color.push(&quot;black&quot;);</div><div class="line">alert(instance1.color);//&quot;red,green,blue,black&quot;</div><div class="line">instance1.sayName();//&quot;Nichola&quot;</div><div class="line">instance1.sayAge();//29</div><div class="line"></div><div class="line">var instance2 = new SubType(&quot;Grey&quot;,24);</div><div class="line">alert(instance2.color);//&quot;red,green,blue&quot;</div><div class="line">instance2.sayAge();//24</div><div class="line">instance2.sayName();//&quot;Grey&quot;</div></pre></td></tr></table></figure></p>
<p>这个方案已经看似perfect了。<strong>但是</strong>，后面再说。</p>
<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p><em>借助原型</em>可以基于已有的对象创建新的对象，不必因此创建自定义类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;     //返回一个对象以传入对象为原型</div><div class="line">    function F()&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person =&#123;</div><div class="line">    name:&quot;Nichola&quot;,</div><div class="line">    friends:[&quot;Shelly&quot;,&quot;Court&quot;,&quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var person1 = object(person);</div><div class="line">person1.name = &quot;Grey&quot;;</div><div class="line">person1.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var person2 = object(person);</div><div class="line">person2.name = &quot;Linda&quot;;</div><div class="line">person2.friends.push(&quot;Barble&quot;);</div><div class="line"></div><div class="line">alert(person.friends);//&quot;Shelly,Court,Van,Grey,Barble&quot;</div></pre></td></tr></table></figure></p>
<p>使用场合：需求简单，只需要让新对象与已有对象保持相似。优点，不必创建构造函数，缺点，包含引用类型值的属性始终共享相应的值。<br><strong>Object.create()正是为实现这种模式诞生。</strong></p>
<h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p>与原型式继承相似，也是基于某个对象或某些信息创建对象，然后增强对象，最后返回对象。实现方法：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回这个对象。看！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function createAnother(original)&#123;</div><div class="line">    var clone = object(original);//通过调用函数创建对象</div><div class="line">    clone.sayHi= function ()&#123;    //增强对象</div><div class="line">        alert(&quot;Hi&quot;);</div><div class="line">    &#125;;</div><div class="line">    return clone;//返回对象</div><div class="line">&#125;</div><div class="line">//可以返回新对象的函数</div><div class="line">function object(o)&#123;</div><div class="line">    function F()&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person =&#123;</div><div class="line">    name:&quot;Nichola&quot;,</div><div class="line">    friends:[&quot;Shelly&quot;,&quot;Court&quot;,&quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi();//&quot;Hi&quot;</div></pre></td></tr></table></figure></p>
<p>这种继承模式适用的场合：任何返回新对象的函数都可以。缺点是不能做到函数复用。</p>
<h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p>上面说到组合继承也有缺点，就是无论在何种情况下，都会调用两次超类型构造函数，一次是在创建子类型原型时，还有一次是在子类型构造函数内部。<br>这种模式集中了寄生式和组合式继承的优点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function  SuperType()&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</div><div class="line">&#125;</div><div class="line">function  SubType()&#123;</div><div class="line">    //第二次调用SuperType()</div><div class="line">    SuperType.call(this,name);</div><div class="line"> </div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">//第一次调用SuperType()</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">SubType.prototype.constructor=SubType;</div><div class="line"></div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Nichola&quot;,29);</div></pre></td></tr></table></figure></p>
<p>第一次调用SuperType():给SubType.prototype写入两个属性name，color<br>第二次调用SuperType()：给instance1写入两个属性name，color<br>实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在SubType.prototype上创建不必要的重复的属性。<br>寄生组合式继承基本模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function  inheritPrototype(SubType,SuperType)&#123;</div><div class="line">    var prototype = object(superType.prototype);//创建对象</div><div class="line">    prototype.constructor = SubType;//增强对象</div><div class="line">    SubType.prototype = prototype;//制定对象</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，创建超类型的一个副本；<br>其次，为副本添加constructor属性，使其指向子类型构造函数；<br>最后，将副本赋值给子类型原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function  SuperType()&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</div><div class="line">&#125;</div><div class="line">function  SubType()&#123;</div><div class="line">    SuperType.call(this,name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">function  inheritPrototype(SubType,SuperType)&#123;</div><div class="line">    var prototype = object(superType.prototype);//创建对象</div><div class="line">    prototype.constructor = SubType;//增强对象</div><div class="line">    SubType.prototype = prototype;//制定对象</div><div class="line">&#125;</div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Nichola&quot;,29);</div></pre></td></tr></table></figure></p>
<p>借用构造函数来继承实例属性，使用寄生式继承来继承超类型的原型，然后再将结果赋给子类型原型。这样既可以继承超类型的实例属性，也可继承超类型原型中的原型属性。这是最优解。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之This]]></title>
      <url>http://yoursite.com/2016/08/22/javascript-1/</url>
      <content type="html"><![CDATA[<p>我们知道，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，当函数被作为某个对象方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此this指向window。</p>
<a id="more"></a>
<h1 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h1><p>在全局环境中（在任何函数体外部），this指代全局对象，无论是否在严格模式下。</p>
<h1 id="函数环境"><a href="#函数环境" class="headerlink" title="函数环境"></a>函数环境</h1><p>在函数内部，this的值取决与函数是如何被调用的。</p>
<h2 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h2><ul>
<li>非严格模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">  return this;</div><div class="line">&#125;</div><div class="line">f1() === window; // true</div></pre></td></tr></table></figure>
</li>
</ul>
<p>f1()是在全局上下文调用的，this 的值总是一个对象且默认为全局对象。</p>
<ul>
<li>严格模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f2()&#123;</div><div class="line">  &quot;use strict&quot;; // 这里是严格模式</div><div class="line">  return this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f2() === undefined; // true</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在严格模式下，this 是在进入运行环境时设置的。若没有定义，this的值将维持undefined状态。</p>
<h2 id="对象方法中"><a href="#对象方法中" class="headerlink" title="对象方法中"></a>对象方法中</h2><p>当以对象方法的方式调用时，this是调用该函数的对象，this的绑定只受最靠近的成员引用的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var o = &#123;prop: 37&#125;;</div><div class="line"></div><div class="line">function independent() &#123;</div><div class="line">  return this.prop;</div><div class="line">&#125;</div><div class="line"></div><div class="line">o.b = &#123;</div><div class="line">  g: independent,</div><div class="line">  prop: 42</div><div class="line">&#125;;</div><div class="line">console.log(o.b.g()); // logs 42</div></pre></td></tr></table></figure></p>
<p>在原型链上，this指向是调用这个方法的对象，表现的好像这个方法存在于这个对象上一样。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>this与即将被创建的新对象绑定。<br>当构造器返回的默认值是一个this引用的对象时，手动的设置了返回对象，与this绑定的默认对象被取消，如果返回值不是一个对象，返回this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Hello1()&#123;</div><div class="line">  this.me = &quot;Kong&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var f1 = new Hello1();</div><div class="line">console.log(f1.me); //Kong</div><div class="line"></div><div class="line"></div><div class="line">function Hello2()&#123;</div><div class="line">  this.he = &quot;Wang&quot;;</div><div class="line">  return &#123;she:&quot;Liu&quot;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> var f2 = new Hello2();</div><div class="line">console.log(f2.she); //Liu</div><div class="line">console.log(f2.he); // undefined</div></pre></td></tr></table></figure></p>
<h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call(),apply()"></a>call(),apply()</h2><p>this绑定到一个指定的对象，即传递给call(),apply()的第一个参数，如何这个参数不是对象，那么JavaScript 将会尝试使用内部 ToObject 操作将其转换为对象。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind</a><br>调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>下面看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var name = &apos;window&apos;;</div><div class="line">var obj = &#123;</div><div class="line">  name :&apos;object&apos;,</div><div class="line">  getName : function () &#123;</div><div class="line">    return this.name;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">alert(obj.getName());//object</div></pre></td></tr></table></figure></p>
<p>不用闭包的情况下，this值为调用该方法的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &apos;window&apos;;</div><div class="line">var obj = &#123;</div><div class="line">  name :&apos;object&apos;,</div><div class="line">  getName : function () &#123;</div><div class="line">    return function()&#123;</div><div class="line">    return this.name;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">alert(obj.getName()());//window</div></pre></td></tr></table></figure></p>
<p>我们编写一个闭包，这时this指向了全局对象。每个函数在调用时都会自动获取两个变量：this和arguments,内部函数在搜索这个变量时，只会搜到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量，又因为前面说过匿名函数的执行环境具有全局性，其this值指向window。所以就有了上面的结果，但是，我们可以把外部作用域的this保存到内部函数可以访问到的变量里，就可以让内部函数访问this了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &apos;window&apos;;</div><div class="line">var obj = &#123;</div><div class="line">  name :&apos;object&apos;,</div><div class="line">  getName : function () &#123;</div><div class="line">    var that =this;</div><div class="line">    return function()&#123;</div><div class="line">    return that.name;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">alert(obj.getName()());//object</div></pre></td></tr></table></figure></p>
<h2 id="DOM事件处理函数"><a href="#DOM事件处理函数" class="headerlink" title="DOM事件处理函数"></a>DOM事件处理函数</h2><p>当函数被用作事件处理函数时，它的this指向触发事件的元素;<br>当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计学习笔记（一）创建对象]]></title>
      <url>http://yoursite.com/2016/08/22/javascript-0/</url>
      <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>可以使用构造函数Object或对象字面量创建单个对象，但是如果使用同一接口创建很多对象会产生大量重复代码。解决办法如下：用函数来封装以特定接口创建对象的细节。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createPerson(name,age,job)&#123;</div><div class="line">    var o = new Object();</div><div class="line">    o.name = name;</div><div class="line">    o.age=age;</div><div class="line">    o.job=job;</div><div class="line">    o.sayName=function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">    return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1=createPerson(&quot;Nicholas&quot;,29,&quot;software Engineer&quot;);</div><div class="line">var person2=createPerson(&quot;Grey&quot;,24,&quot;Doctor&quot;);</div></pre></td></tr></table></figure>
<p>解决了多个相似对象的问题，没有解决对象识别问题。</p>
<h1 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h1><p>创建自定义的构造函数，从而定义自定义对象类型的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job)&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.age=age;</div><div class="line">    this.job=job;</div><div class="line">    this.sayName = function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nocholas&quot;,29,&quot;software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Grey&quot;,24,&quot;Doctor&quot;);</div></pre></td></tr></table></figure></p>
<p>Person()与createPerson()不同之处：</p>
<ul>
<li>没有显示创建对象</li>
<li>直接将属性方法赋给this对象</li>
<li>没有return</li>
</ul>
<p>要创建Person的实例，有以下步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数作用域赋给新对象（this指向新对象）</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>返回新对象</li>
</ol>
<p>创建的person1和person2实例都继承其原型有一个constructor属性，该属性指向Person。而constructor属性最初是用来表示对象类型的，这样就解决了工厂模式无法识别对象类型的问题。<br>构造函数模式也有缺点，每个方法都要在每个实例上重新创造一遍，而不同实例上的同名函数是不相等的。如何实现不同实例共享属性和方法呢，下面原型模式解决了这个问题。</p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向原型对象。原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。在默认情况下，每个原型对象都有一个constructor（构造函数）属性，这个属性也是一个指针，指向prototype属性所在函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">    Person.prototype.name=&quot;Nicola&quot;;</div><div class="line">    Person.prototype.age=23;</div><div class="line">    Person.prototype.job=&quot;Engineer&quot;;</div><div class="line">    Person.prototype.sayName=function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">var person1=new Person();</div><div class="line">person1.sayName();//&quot;Nicola&quot;</div><div class="line"></div><div class="line">var person2=new Person();</div><div class="line">person2.sayName();//&quot;Nicola&quot;</div></pre></td></tr></table></figure></p>
<p>当调用构造函数创建一个实例后，该实例的内部将包含一个指针[[prototype]]指向原型对象。原型对象<em>最初</em>只包含constructor属性，其他的方法是从Object继承而来。<br><img src="http://i1.buimg.com/567571/b30cde583c99e6b5.jpg" alt=""><br>[[prototype]]为内部属性，无法访问到。但是有两个方法：<br>1.isPrototypeOf()确定对象之间是否存在这种不正当关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Person.prototype.isPrototypeOf(person1));//true</div><div class="line">alert(Person.prototype.isPrototypeOf(person2));//true</div></pre></td></tr></table></figure></p>
<p>2.Object.getPrototypeOf()获取一个对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Object.getPrototypeOf(person1)==Person.prototype);//true</div><div class="line">alert(Object.getPrototypeOf(person1).name);//&quot;Nicola&quot;</div></pre></td></tr></table></figure></p>
<p>每当代码读取某个对象的属性时，都会在<em>原型链</em>上搜索，目标是具有给定名字的属性。原型对象中的constructor属性也是实例共享的，可以通过对象实例访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.constructor==Person);//true</div></pre></td></tr></table></figure></p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中的同名属性，这样就阻止我们访问原型对象中的同名属性，但不会修改那个属性，通过delet操作可完全删除实例属性，可重新对原型对象的访问。<br>hasOwnProperty():检测一个属性是否存在于实例中，继承自Object。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">person1.name=&quot;Grey&quot;;</div><div class="line">alert(person1.name);//&quot;Grey&quot;---来自实例</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));//true</div><div class="line">alert(person2.name);//&quot;Nichola&quot;---来自原型</div><div class="line">alert(person2.hasOwnProperty(&quot;name&quot;));//false</div></pre></td></tr></table></figure></p>
<p>Object.getOwnPropertyDescriptor():返回指定对象上一个<em>实例属性</em>对应的属性描述符,不能获取原型对象上的属性描述符。</p>
<h2 id="in操作符"><a href="#in操作符" class="headerlink" title="in操作符"></a>in操作符</h2><p>in操作符只要通过对象能够访问到属性，包括原型链上的，就会返回true。hasOwnProperty()只在属性存在于实例中才会返回true。结合使用可以判断原型链上的属性。<br>1.for-in 循环遍历<br>返回所有能通过对象访问的可枚举的属性，实例属性加原型属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">    Person.prototype.name=&quot;Nicola&quot;;</div><div class="line">    Person.prototype.age=23;</div><div class="line">    Person.prototype.job=&quot;Engineer&quot;;</div><div class="line">    Person.prototype.sayName=function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">var person1=new Person();</div><div class="line">for(var prop in person1)&#123;</div><div class="line">    if (prop==&quot;name&quot;)</div><div class="line">    alert(&quot;found!&quot;)</div><div class="line">&#125;;//&quot;found!&quot;</div><div class="line">console.log(prop);//&quot;sayName&quot;</div></pre></td></tr></table></figure></p>
<p>每个不同的属性，语句都会被执行一次。每次循环，一个不同的属性名将会赋予 prop,最后prop只存有最有一个迭代的属性名。<br>2.Object.keys()<br>该方法会返回一个由给定对象的所有可枚举<em>实例属性</em>（不包括原形链上继承来的书香）的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">    Person.prototype.name=&quot;Nicola&quot;;</div><div class="line">    Person.prototype.age=23;</div><div class="line">    Person.prototype.job=&quot;Engineer&quot;;</div><div class="line">    Person.prototype.sayName=function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">var person1=new Person();</div><div class="line">person1.name=&quot;Rob&quot;;</div><div class="line">person1.age=22;</div><div class="line">var person1keys=object.keys(person1);</div><div class="line">alert(person1keys);//&quot;name,age&quot;</div></pre></td></tr></table></figure></p>
<p>3.Object.getOwnPropertyNames()<br>该方法返回一个由指定对象的所有<em>实例属性</em>的属性名（包括不可枚举属性）组成的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">    Person.prototype.name=&quot;Nicola&quot;;</div><div class="line">    Person.prototype.age=23;</div><div class="line">    Person.prototype.job=&quot;Engineer&quot;;</div><div class="line">    Person.prototype.sayName=function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">var person1=new Person();</div><div class="line">person1.name=&quot;Rob&quot;;</div><div class="line">person1.age=22;</div><div class="line">Object.defineProperty(person1, &quot;key&quot;, &#123;</div><div class="line">  enumerable: false,</div><div class="line">&#125;);//属性key不可枚举</div><div class="line"></div><div class="line">console.log(Object.getOwnPropertyNames(person1).sort());//[&quot;age&quot;, &quot;key&quot;, &quot;name&quot;]</div></pre></td></tr></table></figure></p>
<h2 id="重写原型对象"><a href="#重写原型对象" class="headerlink" title="重写原型对象"></a>重写原型对象</h2><p>用包含所有属性的对象字面量重写原型对象，这样更简便一些，但是会断开了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"> var person1 = new Person();</div><div class="line"> Person.prototype=&#123;</div><div class="line">    constructor:Person,</div><div class="line">    name:&quot;Nicola&quot;,</div><div class="line">    age:23,</div><div class="line">    job:&quot;Engineer&quot;,</div><div class="line">    sayName:function()&#123;</div><div class="line">        alert(this.name);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">person1.sayName();//TypeError: person1.sayName is not a function</div></pre></td></tr></table></figure></p>
<p>重写原型对象之后的关系<br><img src="http://i4.buimg.com/567571/c2342edc484af3ef.jpg" alt=""></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.由于不向构造函数传参，所有实例在默认情况下都会获得相同的属性值。<br>2.共享引用类型值得属性，牵一发动全身不是我们想要的，我们希望每个实例有属于自己的全部属性，改变其中一个的属性，不会影响其他。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"> Person.prototype=&#123;</div><div class="line">    constructor:Person,</div><div class="line">    name:&quot;Nicola&quot;,</div><div class="line">    age:23,</div><div class="line">    job:&quot;Engineer&quot;,</div><div class="line">    friends:[A,B],</div><div class="line">    sayName:function()&#123;</div><div class="line">        alert(this.name);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.friends.push(&quot;C&quot;);</div><div class="line"></div><div class="line">alert(person1.friends);//&quot;A,B,C&quot;</div><div class="line">alert(person2.friends);//&quot;A,B,C&quot;</div></pre></td></tr></table></figure></p>
<p>给person1添加一个朋友C，由于大家引用一个数组，person2也被动的添加了一个朋友C,这是大家不希望看到的，每个实例都应该有自己的隐私。</p>
<h1 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h1><p>这种方式就解决了大每个实例既想要有个对象类型，有共同的属性和方法，也不出卖隐私。构造函数定义实例属性。原型对象定义共享的属性和方法。每个实例有自己的一份实例属性副本，又共享着对方法的引用。这是一种最常见的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function  Person(name,age,job)&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.age=age;</div><div class="line">    this.job=job;</div><div class="line">    this.friends=[&quot;A&quot;,&quot;B&quot;];</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">    constructor:Person,</div><div class="line">    sayName: function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var person1=new Person(&quot;Nichola&quot;,29,&quot;Engineer&quot;);</div><div class="line">var person2=new Person(&quot;Grey&quot;,23,&quot;Doctor&quot;);</div><div class="line"></div><div class="line">person1.friends.push(&quot;C&quot;);</div><div class="line">alert(person1.friends);//&quot;A,B,C&quot;</div><div class="line">alert(person2.friends);//&quot;A,B&quot;</div><div class="line">alert(person1.sayName()==person2.sayName());//TRUE</div></pre></td></tr></table></figure></p>
<h1 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h1><p>动态原型是指视情况而定使用原型模式。把所有信息封装在构造函数之中，在构造函数中初始化原型（在必要情况下），这样就可以同时使用构造函数和原型的优点。通过检查某个应该存在的方法是否有效，来决定是否初始化原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function  Person(name,age,job)&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.age=age;</div><div class="line">    this.job=job;</div><div class="line">    //方法</div><div class="line">    if (typeof this.sayName !=&quot;function&quot;) &#123;</div><div class="line">        Person.prototype.sayName = function()&#123;</div><div class="line">            alert(this.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;Nichola&quot;,29,&quot;Engineer&quot;);</div><div class="line">person1.sayName();//&quot;Nichola&quot;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之闭包]]></title>
      <url>http://yoursite.com/2016/08/17/javascript-2/</url>
      <content type="html"><![CDATA[<blockquote>
<p> 一个闭包就是一个函数和被创建的函数中的作用域对象的组合。–MDN</p>
</blockquote>
<a id="more"></a>
<h1 id="执行环境及作用域链"><a href="#执行环境及作用域链" class="headerlink" title="执行环境及作用域链"></a>执行环境及作用域链</h1><p><em>执行环境</em>（execution context）定义了变量或函数有权访问的其他数据，决定了它们各自的行为。这个说法好抽象。每个执行环境都有一个与之关联的 <em>变量对象</em>(variable object)，环境中定义的所有变量和函数都保存在这个对象中。如果这个环境是函数，则将其 <em>活动对象</em>(activation object)作为变量对象。活动对象最初只包含一个arguments对象。<br>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中。<br>作用域链创建过程：</p>
<ol>
<li>创建函数同时，创建一个预先包含全局变量对象的作用域链，这个会保存在内部的[[Scope]]属性中。</li>
<li>当调用函数时，会为函数创建一个执行环境。</li>
<li>通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。</li>
<li>活动对象被创建并推入执行环境作用域链前端。</li>
</ol>
<p>作用域链本质：是一个指向变量对象的指针列表。<br>作用域链用途：是保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链最前端开始，然后逐级向后回溯，直到找到表示标识符为止。内部环境可以通过作用域链访问所有外部环境，反之不行，可见这些环境之间的联系是线性的，有次序的，单向的。</p>
<p>一般来说，函数执行完毕，其对应的活动对象会被销毁。但是闭包情况下，，其外部函数在执行完毕后，其执行环境的作用域链会被销毁，但是其活动对象仍留在内存中。原因是，内部函数会将外部函数的活动对象添加到自己的作用域链中，即使外部函数执行完毕，内部函数的作用域链仍在引用其活动对象。</p>
<h1 id="for循环中闭包问题"><a href="#for循环中闭包问题" class="headerlink" title="for循环中闭包问题"></a>for循环中闭包问题</h1><p>作用域链这种配置机制引出一个副作用，即在迭代情况下，闭包只能取得包含函数中任何变量的最后一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, arr = []; i &lt;= 3; i++) &#123;</div><div class="line">    arr.push(function() &#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">arr[0](); //4</div><div class="line">arr[1](); //4</div></pre></td></tr></table></figure></p>
<p>for循环执行四次，每次执行都向arr数组中添加一个匿名函数，但是这个匿名函数不执行，不会创建活动对象。当调用数组中的匿名函数时，for循环已经结束，i=4，所以arr中每一项执行的结果都是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, arr = []; i &lt;= 3; i++) &#123;</div><div class="line">    arr.push((function(j) &#123;</div><div class="line">            return function() &#123;</div><div class="line">                alert(j);</div><div class="line">            &#125;;</div><div class="line">        &#125;)(i)</div><div class="line">    );</div><div class="line">&#125;</div><div class="line">arr[0](); //0</div><div class="line">arr[1](); //1</div></pre></td></tr></table></figure></p>
<p>闭包有一个作用保护私有变量，这里j作为外部函数的私有变量被闭包保护起来。function(j)这个外部函数是自执行匿名函数，会创建活动对象，因为闭包的存在，每次执行产生活动对象会保留下来。<br>每次循环外部匿名函数执行时的作用域链之间的关系如图：<br><img src="/images/scopechain.jpg" alt=""></p>
<p>相关资源：<br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-closure/index.html" target="_blank" rel="external">闭包的概念、形式与应用</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">MDN-闭包</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sublime Text3 基础篇]]></title>
      <url>http://yoursite.com/2016/07/24/sublime-1/</url>
      <content type="html"><![CDATA[<h1 id="安装Sublime-Text3"><a href="#安装Sublime-Text3" class="headerlink" title="安装Sublime Text3"></a>安装Sublime Text3</h1><p>Sublime Text<a href="http://www.sublimetext.com/" target="_blank" rel="external">官方网站</a>提供了Sublime Text各系统各版本的下载，目前Sublime Text的最新版本是<a href="http://www.sublimetext.com/3" target="_blank" rel="external">Sublime Text3</a>。这里以Windows版本的SublimeText3安装为例。注意在安装时勾选Add to explorer context menu，这样在右键单击文件时就可以直接使用Sublime Text打开。<br><a id="more"></a></p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>使用<code>Win + R</code>运行<code>sysdm.cpl</code>打开“系统属性”。然后在“高级”选项卡里选择“环境变量”，编辑“Path”，增加Sublime Text的安装目录（例如D:\Sublime Text 3）。<br>接下来就可以在命令行里面利用subl命令直接使用Sublime Text了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">subl file    :: 使用Sublime Text打开file文件</div><div class="line">subl folder  :: 使用Sublime Text打开folder文件夹</div><div class="line">subl .       :: 使用Sublime Text当前文件夹</div></pre></td></tr></table></figure></p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>按功能快捷键列表如下<br>通用（General）</p>
<blockquote>
<p>   Ctrl+Z: 撤销<br>   Ctrl+Y: 恢复撤销<br>   Ctrl+T：词互换<br>   Ctrl + U:回退，软撤销<br>   ↑↓←→：上下左右移动光标，注意不是不是KJHL！<br>   Alt：调出菜单<br>   Ctrl + Shift + P：调出命令板（Command Palette）<br>   Ctrl + `：调出控制台<br>   Ctrl+K+B 开启/关闭侧边栏</p>
</blockquote>
<p>缩进</p>
<blockquote>
<p>   ctrl+] 增加缩进<br>   ctrl+[ 减少缩进<br>   Tab：自动缩进四个空格<br>   Shift+Tab： 去除缩进<br>   ctrl+shift+v ：粘贴时缩进</p>
</blockquote>
<p>编辑（Editing）</p>
<blockquote>
<p>   Ctrl + Enter：在当前行下面新增一行然后跳至该行<br>   Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行<br>   Ctrl + ←/→：进行逐词移动<br>   Ctrl + Shift + ←/→:进行逐词选择<br>   Ctrl + ↑/↓:移动当前显示区域<br>   Ctrl + Shift + ↑/↓:移动当前行，与上下行互换<br>   Ctrl+鼠标左键：可以同时选择要编辑的多处文本<br>   Ctrl+Shift+D ：复制光标所在整行，插入在该行之前<br>   Ctrl+Shift+K ：删除整行<br>   Ctrl+KK ：从光标处删除至行尾<br>   Ctrl+K Backspace ：从光标处删除至行首</p>
</blockquote>
<p>选择（Selecting）</p>
<blockquote>
<p>   Ctrl + D：选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl +<br>   D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl +<br>   K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑<br>   Ctrl + Shift + L：将当前选中区域打散<br>   Ctrl+L：选择整行（按住-继续选择下行）<br>   Ctrl + J：把当前选中区域合并为一行<br>   Ctrl + M：在起始括号和结尾括号间切换，光标移动至括号内开始或结束的位置&gt;<br>   Ctrl + Shift + M：快速选择括号间的内容<br>   Ctrl + Shift + J：快速选择同缩进的内容<br>   Ctrl + Shift + Space：快速选择当前作用域（Scope）的内容<br>   Ctrl+Shift+A ：选择光标位置父标签对儿</p>
</blockquote>
<p>查找&amp;替换（Finding&amp;Replacing）</p>
<blockquote>
<p>   F3：跳至当前关键字下一个位置<br>   Shift+F3：跳到当前关键字上一个位置，可一次性选择全部的相同文本进行同时编辑<br>   Alt + F3：选中当前关键字出现的所有位置<br>   Ctrl + F/H：进行标准查找/替换，之后</p>
<pre><code>* Alt + C：切换大小写敏感（Case-sensitive）模式
* Alt + W：切换整字匹配（Whole matching）模式
* Alt + R：切换正则匹配（Regex matching）模式
* Ctrl + Shift + H：替换当前关键字
* Ctrl + Alt + Enter：替换所有关键字匹配
</code></pre><p>   Ctrl + Shift + F：多文件搜索&amp;替换</p>
</blockquote>
<p>格式</p>
<blockquote>
<p>  Ctrl+Shift+[ ： 折叠代码<br>  Ctrl+Shift+] ：展开代码<br>  Ctrl+K+U ：改为大写<br>  Ctrl+K+L ：改为小写<br>  Alt+. ：闭合当前标签</p>
</blockquote>
<p>注释</p>
<blockquote>
<p>   Ctrl+Shift+/ ：注释已选择内容<br>   Ctrl+/ ：注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</p>
</blockquote>
<p>跳转（Jumping）</p>
<blockquote>
<p>   Ctrl + P：跳转到指定文件，输入文件名后可以：</p>
<pre><code>* @ 符号跳转：输入@symbol跳转到symbol符号所在的位置
* # 关键字跳转：输入#keyword跳转到keyword所在的位置
* : 行号跳转：输入:12跳转到文件的第12行。
</code></pre><p>   Ctrl + R：跳转到指定符号 快速列出/<br>   跳转到某个函数，对于Markdown，会列出其大纲<br>   Ctrl + G：跳转到指定行号</p>
</blockquote>
<p>窗口（Window）</p>
<blockquote>
<p>   Ctrl + Shift + N：创建一个新窗口<br>   Ctrl + N：在当前窗口创建一个新标签<br>   Ctrl + W：关闭当前标签，当窗口内没有标签时会关闭该窗口<br>   Ctrl + Shift + T：恢复刚刚关闭的标签<br>   Ctrl+Tab： 当前窗口中的标签页切换<br>   Ctrl+F2 ：设置/取消书签<br>  Shift+F2 ：上一个书签</p>
</blockquote>
<p>屏幕（Screen）</p>
<blockquote>
<p>   F11：切换普通全屏<br>   Shift + F11：切换无干扰全屏<br>   Alt+Shift+1:（非小键盘）窗口分屏，恢复默认1屏<br>   Alt+Shift+2:左右分屏-2列<br>   Alt+Shift+3:左右分屏-3列<br>   Alt+Shift+4: 左右分屏-4列<br>   Alt+Shift+5:等分4屏<br>   Alt+Shift+8: 垂直分屏-2屏<br>   Alt+Shift+9: 垂直分屏-3屏<br>   分屏之后，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift +<br>   数字键将当前屏移动到指定屏</p>
</blockquote>
<h1 id="快捷键配置"><a href="#快捷键配置" class="headerlink" title="快捷键配置"></a>快捷键配置</h1><p><a href="http://sublime-text-unofficial-documentation.readthedocs.io/en/latest/reference/settings.html" target="_blank" rel="external">系统快捷键的默认配置</a><br>自定义快捷键配置：<br>打开<code>Preferences -&gt; Key Bindings - User</code></p>
<h1 id="Sublime-Text内运行javascript-ES6"><a href="#Sublime-Text内运行javascript-ES6" class="headerlink" title="Sublime Text内运行javascript(ES6)"></a>Sublime Text内运行javascript(ES6)</h1><p>1.首先安装nodejs<br>当然你可以使用其它诸如jsc之类的环境来运行js, 本文使用的是nodejs. 首先确保你的电脑已经安装好nodejs, 并已将其添加到环境变量中 (一般安装时自动添加或者询问是否添加)</p>
<p>2.添加build system<br>在sublime text中依次打开<code>Tools -&gt; Build System -&gt; New Build System…</code>粘贴以下代码后保存(如Node.sublime-build), 然后把Build System设成Automatic<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; “cmd”: [“node”, “—use-strict”, “—harmony”, “$file”], “selector”: “source.js”&#125;</div></pre></td></tr></table></figure></p>
<p>3.附加说明<br>在以上的build文件中(Node.sublime-build), node是执行命令,<code>—harmony</code>和<code>—use-strict</code>是执行参数, <code>$file</code>是当前文件名, 所以一次build操作实际上相当于在命令行中执行了<code>node —use-strict —harmony filename</code>. <code>—harmony</code>表示启用ES Harmony features, 而这些features目前只能在strict模式下运行, 所以需要同时添加<code>use-strict</code>参数(详见<a href="http://stackoverflow.com/questions/17253509/what-is-extended-mode" target="_blank" rel="external">what-is-extended-mode</a>).<br>如果不想启用es6的特性,把build文件更改成以下代码保存即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; “cmd”: [“node”, “$file”], “selector”: “source.js”&#125;</div></pre></td></tr></table></figure></p>
<p>4.具体使用<br>在sublime test中新建一个test.js文件, 然后输入你的测试代码, 比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (let i = 0; i &lt; 3; i++) &#123;</div><div class="line">    console.log(&apos;i:&apos;, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用快捷键 <code>ctrl + b</code>, 将得到以下执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i: 0i: 1i: 2[Finished in 0.1s]</div></pre></td></tr></table></figure></p>
<p>注解:</p>
<blockquote>
<p>  (1)文件必须是存在于磁盘中的, 而不是untitled的,<br>  否则sublime无法找到相应的文件.<br>  (2)Nodejs安装目录需要加入path环境变量中，否则Ctrl+B运行 会出现：<br>  [WinError2] 系统找不到指定的文件。</p>
</blockquote>
<h1 id="正则表达式（学习中）·"><a href="#正则表达式（学习中）·" class="headerlink" title="正则表达式（学习中）·"></a>正则表达式（学习中）·</h1><p><em><a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="external">正则表达式</a></em>是非常强大的文本查找&amp;替换工具，Sublime Text中使用Alt + R切换正则匹配模式的开启/关闭。Sublime Text的使用<em><a href="http://www.boost.org/doc/libs/1_44_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="external">Boost里的Perl正则表达式风格</a></em>。<br><a href="http://regex.info/" target="_blank" rel="external">Mastering Regex</a>（中译本：<a href="http://book.douban.com/subject/2154713/" target="_blank" rel="external">精通正则表达式</a>）对正则表达式的原理和各语言下的使用进行了详细介绍。<br>优秀教程：<br><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">“正则表达式30分钟入门教程”</a><br><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90" target="_blank" rel="external">MSDN正则表达式教程</a>)<a href="http://www.williamlong.info/archives/433.html" target="_blank" rel="external">月光博客～常用正则表达式</a>在线测试工具：<br><a href="http://regexpal.com/" target="_blank" rel="external">regexpal</a><br><a href="http://www.regexr.com/" target="_blank" rel="external">regexer</a></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="http://sublime-text-unofficial-documentation.readthedocs.org/" target="_blank" rel="external">非官方文档</a><br><a href="http://www.sublimetext.com/docs/3/" target="_blank" rel="external">官方文档</a><br><a href="https://sublime.wbond.net/" target="_blank" rel="external">Package Control</a> 大量的Sublime Text插件和主题。<br><a href="http://zh.lucida.me/blog/sublime-text-complete-guide/" target="_blank" rel="external">Sublime Text 全程指南</a><br><a href="http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#three" target="_blank" rel="external">如何优雅地使用Sublime Text</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSHint使用基础]]></title>
      <url>http://yoursite.com/2016/07/23/nodejs-1/</url>
      <content type="html"><![CDATA[<p>JSHint是一款在线的js代码验证工具，它能帮助你找出在开发中不经意犯下错误和可能存在的潜在问题。强烈建议尽可能的使用检查工具来确认你的编码风格以及设计模式的正确性。JSHint 提供在线和本地使用(基于 Node.js)。同时，还有很多插件支持VS，Eclipse，Notepad++，Sublime Text等。<br><a id="more"></a><br>JSHint主页：<a href="http://jshint.com/" target="_blank" rel="external">http://jshint.com/</a><br>JSHint下载安装：<a href="http://jshint.com/install/" target="_blank" rel="external">http://jshint.com/install/</a><br>JSHint官方文档：<a href="http://jshint.com/docs/" target="_blank" rel="external">http://jshint.com/docs/</a><br>Github：<a href="https://github.com/jshint/jshint/" target="_blank" rel="external">https://github.com/jshint/jshint/</a><br><a href="http://www.hyjiacan.com/javascript-jshint/" target="_blank" rel="external">Javascript代码验证工具 JSHint</a></p>
<h1 id="安装jshint"><a href="#安装jshint" class="headerlink" title="安装jshint"></a>安装jshint</h1><p>在Node.js上全局安装jshint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install jshint -g</div></pre></td></tr></table></figure></p>
<p>在对应目录下运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ jshint move.js</div><div class="line">move.js: line 41, col 10, Missing semicolon.</div><div class="line"></div><div class="line">1 error</div></pre></td></tr></table></figure></p>
<p>一个错误，少一个分号。<br>如果路径是短横线 (-)，那么JSHint会从标准输入读取数据。</p>
<h1 id="配置JSHint"><a href="#配置JSHint" class="headerlink" title="配置JSHint"></a>配置JSHint</h1><p>有三种配置方式：<br>1.使用指定的配置文件 .jshintrc</p>
<blockquote>
<p>这个设置允许您每个项目有不同的配置文件。把你的文件放到项目根目录,只要你运行<br>JSHint从任何地方在你的项目目录树,将使用相同的配置文件。</p>
</blockquote>
<p>JSHint默认使用用户home目录下的.jshintrc文件（json格式）作为配置文件,也可以在你的项目目录下添加一个.jshintrc文件，JSHint会在检测文件时从文件所在目录往上找，直到找到jshintrc文件为止。<br><a href="https://github.com/jshint/jshint/blob/master/examples/.jshintrc" target="_blank" rel="external">jshintrc文件示例</a></p>
<p>2.通过 –config标记手动配置<br>如果你并没有将规则文件命名为符合规则的名字（即用.jshintrc），那么可以在运行JSHint的时候手动指定规则文件，例如你将规则文件命名为jshint.json。那么可以使用一下命令来运行JSHint并应用你的规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jshint my_app.js --config /root/application/jshint.json  //指定规则文件路径</div></pre></td></tr></table></figure></p>
<p>3.把配置写在 jshintConfig 目录下的 package.json 文件中<br> 配置文件是指定了JSHint配置选项开头的json数据格式，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;  &quot;undef&quot;: true,  &quot;unused&quot;: true,  &quot;globals&quot;: &#123; &quot;MY_GLOBAL&quot;: false &#125;&#125;</div></pre></td></tr></table></figure></p>
<p>上面的配置中，JSHint 会对未定义(undefined)和未使用(unused) 的变量发出警告，globals是指定全局变量。</p>
<h1 id="内置配置"><a href="#内置配置" class="headerlink" title="内置配置"></a>内置配置</h1><p>对于需要对单个文件进行特定设置的需求，我们可以在文件最上方使用注释行来设定JSHint:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* jshint undef: true, unused: true */</div><div class="line">/* globals MY_GLOBAL */</div></pre></td></tr></table></figure></p>
<p>上面代码片段将启用警告未定义的和未使用的变量和告诉JSHint全局变量命名MY_GLOBAL。<br>类似对于文件的设定，对于函数的设定方式需要把相应的注释行移到函数内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// From another file</div><div class="line">function b() &#123;</div><div class="line">  &quot;use strict&quot;;</div><div class="line">  /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="屏蔽警告"><a href="#屏蔽警告" class="headerlink" title="屏蔽警告"></a>屏蔽警告</h2><p>某些警告是无法通过错误来进行屏蔽的，这时候你首先需要知道你要屏蔽错误的错误代码，通过添加<code>--verbose</code>参数来获得：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jshint --verbose myfile.js</div><div class="line">myfile.js: line 6, col 3, Unnecessary directive &quot;use strict&quot;. (W034)</div></pre></td></tr></table></figure></p>
<p>如果需要屏蔽这个错误，可在文件中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* jshint -W034 */</div></pre></td></tr></table></figure></p>
<p>这样，代码为 W034的警告就会被隐藏。有两点需要注意:</p>
<blockquote>
<ol>
<li>这种语法只对警告(W开头的代码)有效，而对错误 (E开头的代码)是无效的。</li>
<li>这种语法会隐藏所有指定代码的警告。</li>
</ol>
</blockquote>
<p>要重新显示上面隐藏的警告，使用下面的语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* jshint +W034 */</div></pre></td></tr></table></figure></p>
<h1 id="JSHint-指令"><a href="#JSHint-指令" class="headerlink" title="JSHint 指令"></a>JSHint 指令</h1><p>jshint: 设置JSHint选项指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* jshint strict: true */</div></pre></td></tr></table></figure></p>
<p>jslint：设置是否兼容 JSLint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* jslint vars: true */</div></pre></td></tr></table></figure></p>
<p>globals: 告诉 JSHint 全局变量是在其它地方定义的。当值(value)为false(默认)时，JSHint会认为变量是只读的。通常和 undef 选项一起使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* global MY_LIB: false */</div></pre></td></tr></table></figure></p>
<p>在globals配置中，也可以把全局变量加到黑名单中，以使得变量在当前文件中禁用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* global -BAD_LIB */</div></pre></td></tr></table></figure></p>
<p>exported: 告诉 JSHint 变量在当前文件定义但是会在其它文件中使用的指令，通常和 unused 指令一起使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* exported EXPORTED_LIB */</div></pre></td></tr></table></figure></p>
<p>ignore: 告诉 JSHint 要跳过的代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Code here will be linted with JSHint.</div><div class="line">/* jshint ignore:start */</div><div class="line">// Code here will be linted with ignored by JSHint.</div><div class="line">/* jshint ignore:end */</div></pre></td></tr></table></figure></p>
<p>JSHint会跳过检查所有位于/<em> jshint ignore:start </em>/ 和/<em> jshint ignore:end </em>/ 间的代码。<br>也可以在行的尾部添加行注释以跳过当前行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ignoreThis(); // jshint ignore:line</div></pre></td></tr></table></figure></p>
<h1 id="JSHint-选项"><a href="#JSHint-选项" class="headerlink" title="JSHint 选项"></a>JSHint 选项</h1><p>JSHint本身是个命令行工具，它提供了灵活了的选项设置方式。<br>JSHint 有两种选项: <code>enforcing</code> 和<code>relaxing</code><br><code>enforcing</code> 用于使JSHint的检查更加严格，而<code>relaxing</code>用于阻止一些警告。<br><a href="https://github.com/jshint/jshint/blob/master/examples/.jshintrc" target="_blank" rel="external">更多选项在jshintrc文件示例</a><br><a href="http://jshint.com/docs/options/" target="_blank" rel="external">更多选项的含义见官方文档</a></p>
<h1 id="hacker的方式"><a href="#hacker的方式" class="headerlink" title="hacker的方式"></a>hacker的方式</h1><p>上面说的方式官方的文档都有更加详细的说明，可如果你总是想禁用掉特定的警告该怎么办呢?比方说对于以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (err) return next(err);</div></pre></td></tr></table></figure></p>
<p>JSHint会警告<code>Expected &#39;{&#39; and instead saw &#39;return&#39;.</code>，因为我（node社区很多人也是）不喜欢在单行的返回代码前后添加大括号，但是我也不想总是在文件最上面添加注释添加一块专门的注释来禁用它。一种可行的办法是修改编辑器的代码检测插件，不过难度有点高，另一种方法就是修改JSHint 的代码，我们只需要对一个reporter文件稍做修改即可。打开文件<code>jshint/src/reporters/default.js</code>，在<code>var error = result.error;</code>下面加入两行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var code = error.code;</div><div class="line">if (code === &apos;W116&apos;) return;</div></pre></td></tr></table></figure></p>
<p>大功告成，保存以后再用JSHint就再也看不到那样的警告了。（当然，如果你的JSHint使用别的reporter那就另当别论了）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Winsows上Nodejs的安装配置]]></title>
      <url>http://yoursite.com/2016/07/23/nodejs-0/</url>
      <content type="html"><![CDATA[<h1 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h1><blockquote>
<p>系统：windows8.1</p>
</blockquote>
<p>最简单安装的方法，在<a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>下载.msi格式，或者从我的百度云盘链接: <a href="http://pan.baidu.com/s/1mim4hvU" target="_blank" rel="external">http://pan.baidu.com/s/1mim4hvU</a> 密码: scaf，默认安装会自动配置环境变量，也可以更改安装目录。我的安装目录<code>C:\Program Files\nodejs</code>。npm已经集成在nodejs，不用单独安装。在该目录下新建两个文件夹node_cache和node_global。</p>
<a id="more"></a>
<p><img src="http://i1.piimg.com/567571/62c1c72771c19ca2.png" alt="nodejs目录结构"><br>node_cache是npm缓存目录，避免相同的包每次都下载。<br>node_global是全局安装的目录。</p>
<blockquote>
<p><code>npm install xxx -g</code>时， 模块将被下载安装到”全局目录”中。”全局目录”通过<br><code>npm config set prefix</code>“目录路径” 来设置。<br>通过 <code>npm config get prefix</code> 来获取当前设置的目录。使用全局安装方式统一安装的<br>一个目录中去,这样既方便管理、结构清晰还可以重复利用。</p>
</blockquote>
<p>在管理员身份下运行cmd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set cache &quot;C:\Program Files\nodejs\node_cache&quot;</div><div class="line">npm config set prefix &quot;C:\Program Files\nodejs\node_global&quot;</div></pre></td></tr></table></figure></p>
<h1 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h1><p>由于改变了node_modules的默认安装目录,需要重新配置环境变量,<code>计算机\&gt;系统属性\&gt;高级\&gt;环境变量</code><br>用户环境变量<br>编辑PATH:<code>C:\Program Files\nodejs\node_modules\npm;C:\Program Files\nodejs\node_global</code><br>添加NODE_PATH:<code>C:\Program Files\nodejs\node_global\node_modules</code><br>系统环境变量<br>编辑path：<code>C:\Program Files\nodejs\</code></p>
<h1 id="Windows-系统下设置Nodejs-NPM全局路径"><a href="#Windows-系统下设置Nodejs-NPM全局路径" class="headerlink" title="Windows 系统下设置Nodejs NPM全局路径"></a>Windows 系统下设置Nodejs NPM全局路径</h1><p>在cmd下执行以下命令无效的情况下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set cache &quot;C:\Program Files\nodejs\node_cache&quot;</div><div class="line">npm config set prefix &quot;C:\Program Files\nodejs\node_global&quot;</div></pre></td></tr></table></figure>
<p>在nodejs的安装目录中找到<code>node_modules\npm\.npmrc文件</code>（C:\Program Files\nodejs\node_modules\npm）</p>
<p>修改如下即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">prefix=C:\Program Files\nodejs\node_global</div><div class="line">cache=C:\Program Files\nodejs\node_cache</div></pre></td></tr></table></figure></p>
<h1 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h1><p>安装完成后在管理员下运行cmd<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-7-23/79224504.jpg" alt="安装nodejs版本号"><br>如上图所示则安装成功</p>
<h1 id="安装相关环境"><a href="#安装相关环境" class="headerlink" title="安装相关环境"></a>安装相关环境</h1><p>切记在管理员下运行cmd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g jshint</div><div class="line">npm install -g csslint</div></pre></td></tr></table></figure></p>
<h1 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a>全局安装与本地安装</h1><p><code>npm install -g ***</code>表示全局安装，这样安装的安装包都在当前用户下，在磁盘的所有其他地方都可以访问到，比较方面。否则<code>npm install ***</code>表示本地安装，安装在当前目录下，只能在当前目录下使用。<br>如果一个包是要当做命令一样的来使用，就推荐进行全局安装，而如果一个包是使用在项目里面的话，则使用本地安装，这样避免了不同项目对不同版本的包之间的相互依赖的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git与Github]]></title>
      <url>http://yoursite.com/2016/07/23/git-0/</url>
      <content type="html"><![CDATA[<p>Git 是一个为了更好地管理 Linux内核开发而创立的分布式版本控制和软件配置管理软件。 国内外知名 Git 代码托管网站有：<br><a href="http://GitHub.com" target="_blank" rel="external">github</a><br><a href="http://Coding.net" target="_blank" rel="external">Coding</a><br><a href="http://code.csdn.net/" target="_blank" rel="external">code.csdn</a><br><a id="more"></a></p>
<p>GitHub 使用 Git 作为版本控制系统（version control system）提供在线源码托管的服务，同时是个有社交功能的开发者社区。<br>国外类似服务：<br><a href="https://bitbucket.org/" target="_blank" rel="external">Bitbucket</a><br><a href="http://Gitlab.com" target="_blank" rel="external">Gitlab</a><br>国内类似服务：<br><a href="http://Gitcafe.com" target="_blank" rel="external">Gitcafe</a></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程 - 廖雪峰的官方网站</a><br><a href="https://git-scm.com/book/en/v2" target="_blank" rel="external">Pro Git</a><br><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简明指南</a><br><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解 Git</a><br><a href="http://www.yangzhiping.com/tech/github.html" target="_blank" rel="external">如何高效利用GitHub–阳志平</a><br><a href="http://www.worldhello.net/gotgithub/#id4" target="_blank" rel="external">worldhello</a><br><a href="help.github.com/">Github帮助文档</a><br><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/index.html" target="_blank" rel="external">Git Magic</a></p>
<h1 id="过后填坑···"><a href="#过后填坑···" class="headerlink" title="过后填坑···"></a>过后填坑···</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sublime Text3 前端插件安装与使用]]></title>
      <url>http://yoursite.com/2016/07/05/sublime-0/</url>
      <content type="html"><![CDATA[<h1 id="安装package-control"><a href="#安装package-control" class="headerlink" title="安装package control"></a>安装package control</h1><p>安装插件需要先安装package control，有两种安装package control的方法，<a href="https://packagecontrol.io/installation" target="_blank" rel="external">官方安装方法</a><br><a id="more"></a></p>
<ul>
<li>控制台安装<br>在sublime text3<code>ctrl+~</code>呼出控制台或者<code>View &gt; Show Console</code>,然后在控制台粘贴以下Python code：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>上面的代码根据版本不同会更新，所以每次使用都链接上方的地址获取</p>
</blockquote>
<p>上面的代码会创建安装<code>Installed Packages</code>的文件夹，自动下载<code>Package Control.sublime-package</code>到这个文件夹。</p>
<ul>
<li><p>手动安装</p>
<ol>
<li>进入 Preferences &gt; Browse Packages…</li>
<li>进入 <code>Installed Packages/</code> 目录下</li>
<li>下载 <code>[Package Control.sublime-package](https://packagecontrol.io/Package%20Control.sublime-package)</code>到 <code>Installed  Packages/</code>目录下。</li>
<li>重启 Sublime Text3</li>
</ol>
</li>
</ul>
<h1 id="安装插件的常用方法"><a href="#安装插件的常用方法" class="headerlink" title="安装插件的常用方法"></a>安装插件的常用方法</h1><ul>
<li><code>ctrl+shift+p</code>进入Command Palette，输入<code>install</code>进入 Package Control: Install Package，输入要安装的插件的名称回车安装。</li>
<li>如果在在列表中没有要安装的插件，可以在github上下载插件安装包，然后打开菜单栏里的“Preferences”—&gt;”Browse Packages”，打开包的位置，然后将下载的Zip包“解压”后复制到该文件夹内即可，重启Sublime Text3 插件就会安装成功了。</li>
</ul>
<h1 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h1><p> <a href="http://docs.emmet.io/" target="_blank" rel="external">Emmet官方使用文档</a><br> <a href="http://yanxyz.github.io/emmet-docs/" target="_blank" rel="external">EMMET中文文档参考 yanxyz@github</a><br> <a href="http://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">速查表</a><br> Emmet使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度。<br> 直接在编辑器中输入HTML或CSS的代码的缩写，然后按tab键就可以拓展为完整的代码片。</p>
<h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><pre><code>1. 展开缩写
2. 匹配标签
3. 跳转到配对标签
4. 包裹缩写
5. 跳转到编辑点
6. 选择
7. 切换注释
8. 分割合并标签
9. 删除标签
10. 合并行
11. 更新图片尺寸
12. 计算数学表达式
13. 增减数字
14. 重构 CSS 值
15. 编码/解码图像为 data:URL
</code></pre><p>缩写是 Emmet的核心：这些特殊的表达式被实时的解析转化为代码块，缩写的语法类似于 CSS 选择器。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>所有未知的缩写都会转换成标签，例如，<code>foo → &lt;foo&gt;&lt;/foo&gt;</code><br>后代：&gt;<br>兄弟：+<br>上级：^<br>分组：()<br>乘法：*<br>自增符号：$<br>ID：#<br>类属性：.<br>自定义属性：[title=”Hello world”]<br>文本：{}<br>隐式标签：当展开缩写时，Emmet 尝试获取缩写所处位置的父元素上下文，比如 HTML 元素。如果获取成功，Emmet 使用它的名字来解析隐式标签名。</p>
<h2 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h2><p>当编辑 HTML/XML 文档时，缩写展开为 HTML/XML 标签。不过一些元素，比如 a 或 img， 缩写展开后带有属性：<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>或<code>&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;</code>。Emmet 所有元素的定义放在 <code>snippets.json</code> 文件里，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;html&quot;: &#123;</div><div class="line">        &quot;abbreviations&quot;: &#123;</div><div class="line">            &quot;a&quot;: &quot;&lt;a href=\&quot;\&quot;&gt;&quot;,</div><div class="line">            &quot;link&quot;: &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;\&quot; /&gt;&quot;</div><div class="line">            ...</div><div class="line">        &#125;,</div><div class="line">        &quot;snippets&quot;: &#123;</div><div class="line">            &quot;cc:ie6&quot;: &quot;&lt;!--[if lte IE 6]&gt;\n\t$&#123;child&#125;|\n&lt;![endif]--&gt;&quot;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    &quot;css&quot;: &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="css缩写"><a href="#css缩写" class="headerlink" title="css缩写"></a>css缩写</h2><ol>
<li>在属性前或缩写前放一个连字符，Emmet 会自动给这个属性添加厂商前缀。</li>
<li>渐变<br>可以输入函数 lg(…) (或 linear-gradient(…)) 函数，并且像缩写一样展开。如果用做属性值，Emmet 将使用属性名来生成新的属性。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient" target="_blank" rel="external">linear-gradient</a></li>
<li>模糊匹配<br>为了让书写 CSS 更容易， Emmet 实现了模糊查找。每次输入未知的缩写时，Emmet 尝试查找最相近的代码片断。<br>例如，缩写不是 ov:h(overflow: hidden;) ，而是 ov-h, ovh 甚至 oh。</li>
<li><p>值<br>比如我们在写 width：100px的时候，只需要 w100 即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p 表示%</div><div class="line">e 表示 em</div><div class="line">x 表示 ex</div></pre></td></tr></table></figure>
</li>
<li><p>附加属性<br>@f可以生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@font-face &#123;</div><div class="line">font-family:;</div><div class="line">src:url();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="html-缩写"><a href="#html-缩写" class="headerlink" title="html 缩写"></a>html 缩写</h2><p>所有未知的缩写都会转换成标签，例如，foo → <foo></foo><br>! ：生成后h5文档<br>a ：<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code><br>更多查<a href="http://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">速查表</a></p>
<h1 id="SublimeLinter"><a href="#SublimeLinter" class="headerlink" title="SublimeLinter"></a>SublimeLinter</h1><p>SublimeLinter 是前端编码利器——Sublime Text 的一款插件，用于高亮提示用户编写的代码中存在的不规范和错误的写法，支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言。如何在 Windows 中配置 SublimeLinter 进行 JS &amp; CSS 校验?</p>
<h2 id="SublimeLinter-jshint"><a href="#SublimeLinter-jshint" class="headerlink" title="SublimeLinter-jshint"></a>SublimeLinter-jshint</h2><p>安装此插件之前需要确保本机安装jshint,在安装nodejs(<em>Winsows上Nodejs的安装配置</em>)下安装jshint（**）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g jshint</div><div class="line">npm install -g csslint</div></pre></td></tr></table></figure></p>
<p><a href="https://packagecontrol.io/packages/SublimeLinter" target="_blank" rel="external">主页</a></p>
<h1 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h1><p>侧边栏加强软件:CTRL+K,CTRL+B<br>可配置打开方式,使html文件直接通过快捷键以浏览器打开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//chrome</div><div class="line">  &#123; &quot;keys&quot;: [&quot;ctrl+1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,</div><div class="line">          &quot;args&quot;: &#123;</div><div class="line">              &quot;paths&quot;: [],</div><div class="line">              &quot;application&quot;: &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;,</div><div class="line">              &quot;extensions&quot;:&quot;.*&quot;</div><div class="line">          &#125;</div><div class="line">   &#125;,</div><div class="line">   //Firefox</div><div class="line">   &#123; &quot;keys&quot;: [&quot;ctrl+2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,</div><div class="line">          &quot;args&quot;: &#123;</div><div class="line">              &quot;paths&quot;: [],</div><div class="line">              &quot;application&quot;: &quot;E:\\firefox\\firefox.exe&quot;,</div><div class="line">              &quot;extensions&quot;:&quot;.*&quot;</div><div class="line">          &#125;</div><div class="line">   &#125;,</div><div class="line">   //opera</div><div class="line">    &#123; &quot;keys&quot;: [&quot;ctrl+3&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,</div><div class="line">          &quot;args&quot;: &#123;</div><div class="line">              &quot;paths&quot;: [],</div><div class="line">              &quot;application&quot;: &quot;C:\\Program Files\\Opera developer\\launcher.exe&quot;,</div><div class="line">              &quot;extensions&quot;:&quot;.*&quot;</div><div class="line">          &#125;</div><div class="line">   &#125;,</div><div class="line">   //ie</div><div class="line">    &#123; &quot;keys&quot;: [&quot;ctrl+4&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,</div><div class="line">          &quot;args&quot;: &#123;</div><div class="line">              &quot;paths&quot;: [],</div><div class="line">              &quot;application&quot;: &quot;C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe&quot;,</div><div class="line">              &quot;extensions&quot;:&quot;.*&quot;</div><div class="line">          &#125;</div><div class="line">   &#125;,</div></pre></td></tr></table></figure></p>
<p><a href="https://packagecontrol.io/packages/SideBarEnhancements" target="_blank" rel="external">更多</a><br><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">github主页</a></p>
<h1 id="SideBarFolders"><a href="#SideBarFolders" class="headerlink" title="SideBarFolders"></a>SideBarFolders</h1><p>打开的文件夹都太多了，再用这个来管理文件夹<br><a href="https://packagecontrol.io/packages/SideBarFolders" target="_blank" rel="external">更多</a><br><a href="https://github.com/titoBouzout/SideBarFolders" target="_blank" rel="external">github</a></p>
<h1 id="BracketHighlighter"><a href="#BracketHighlighter" class="headerlink" title="BracketHighlighter"></a>BracketHighlighter</h1><p><a href="https://sublime.wbond.net/packages/BracketHighlighter" target="_blank" rel="external">BracketHighlighter</a>插件以高亮显示配对括号以及当前光标所在区域</p>
<h1 id="JSFormat"><a href="#JSFormat" class="headerlink" title="JSFormat"></a>JSFormat</h1><p>功能：Javascript的代码格式化插件<br>简介：很多网站的JS代码都进行了压缩，一行式的甚至混淆压缩，这让我们看起来很吃力。而这个插件能帮我们把原始代码进行格式的整理，包括换行和缩进等等，是代码一目了然，更快读懂。<br>使用：在已压缩的JS文件中，右键选择jsFormat或者使用默认快捷键（Ctrl+Alt+F）<br><a href="https://packagecontrol.io/packages/JsFormat" target="_blank" rel="external">更多</a><br><a href="https://github.com/jdc0589/JsFormat" target="_blank" rel="external">github</a></p>
<h1 id="TrailingSpaces"><a href="#TrailingSpaces" class="headerlink" title="TrailingSpaces"></a>TrailingSpaces</h1><p>有时候，在代码结尾打多了几个空格或Tab并没有任何显示效果TrailingSpaces这款插件能高亮显示多余的空格和Tab.<br><a href="https://packagecontrol.io/packages/TrailingSpaces" target="_blank" rel="external">更多</a><br><a href="https://github.com/SublimeText/TrailingSpaces" target="_blank" rel="external">github</a></p>
<h1 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h1><p>功能：”=”号对齐<br>简介：变量定义太多，长短不一，可一键对齐<br>使用：默认快捷键Ctrl+Alt+A和QQ截屏冲突，可设置其他快捷键如：Ctrl+Shift+Alt+A；先选择要对齐的文本<br><a href="https://packagecontrol.io/packages/Alignment" target="_blank" rel="external">更多</a></p>
<h1 id="ColorPicker"><a href="#ColorPicker" class="headerlink" title="ColorPicker"></a>ColorPicker</h1><p>一款取色器:CTRL+ALT+C.</p>
<h1 id="sublimeREPL"><a href="#sublimeREPL" class="headerlink" title="sublimeREPL"></a>sublimeREPL</h1><p>SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ， Python，Ruby， Scala 和 Haskell 等）。Sublime Text的Python控制台仅支持单行输入，十分不方便，所以Sublime​REPL以进行一些编码实验（Experiments）。</p>
<h1 id="DocBlocker"><a href="#DocBlocker" class="headerlink" title="DocBlocker"></a>DocBlocker</h1><p>对方法等进行注释,一个真正简单的方式来轻松地创建许多语言包括JavaScript，PHP和CoffeeScript的文档块。只要在函数的上面输入/**，按Tab就可以了。DocBlockr会观察函数需要的变量名和类型，并创建文档块。</p>
<p><a href="https://github.com/spadgos/sublime-jsdocs" target="_blank" rel="external">github</a></p>
<h1 id="CSScomb"><a href="#CSScomb" class="headerlink" title="CSScomb"></a>CSScomb</h1><p>CssComb是为CSS属性进行排序和格式化插件,<a href="http://csscomb.com/" target="_blank" rel="external">官网</a><br>它依赖于Node.js，安装NodeJS后，即可使用CssComb插件，nodejs安装见此（**）<br>使用：菜单<code>Tools-&gt;Run CSScomb</code>或在CSS文件中按快捷键<code>Ctrl+Shift+C</code></p>
<h1 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h1><p>在编程过程中，我们经常需要使用到命令行窗口,Terminal插件可以允许在Sublime Text 3中打开cmd命令窗口,安装好该插件后,即可使用快捷键<code>Ctrl+Shift+T</code>呼出命令行窗口。</p>
<h1 id="MarkDown-Editing"><a href="#MarkDown-Editing" class="headerlink" title="MarkDown Editing"></a>MarkDown Editing</h1><p>支持Markdown语法高亮,支持Github Favored Markdown语法,自带3个主题。</p>
<h1 id="MarkdownPreview"><a href="#MarkdownPreview" class="headerlink" title="MarkdownPreview"></a>MarkdownPreview</h1><p>MarkdownPreview：按<code>CTRL + B</code>生成网页HTML，在最前面添加<code>[TOC]</code>自动生成目录。</p>
<h1 id="Autoprefixer"><a href="#Autoprefixer" class="headerlink" title="Autoprefixer"></a>Autoprefixer</h1><p>这是一款CSS3私有前缀自动补全插件，该插件使用CanIUse资料库，能精准判断哪些属性需要什么前缀，与CssComb插件一样，该插件也需要系统已安装Node.js环境。<br>使用方法：在输入CSS3属性后（冒号前）按Tab键。</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>在工作中，版本控制软件最常用的软件之一，而最流行的VCS是Git。你是否厌倦了保存文本文件，并切换回终端运行一些 Git 命令。如果你能从文本编辑器本身执行Git命令，岂不是很好？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo使用]]></title>
      <url>http://yoursite.com/2016/07/01/hexo-1/</url>
      <content type="html"><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>默认目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy</div><div class="line">├── public</div><div class="line">├── scaffolds</div><div class="line">├── scripts</div><div class="line">├── source</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">├── themes</div><div class="line">├── _config.yml</div><div class="line">└── package.json</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<ul>
<li>deploy：执行hexo deploy命令部署到GitHub上的内容目录</li>
<li>public：执行hexo generate命令，输出的静态网页内容目录</li>
<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li>
<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>
<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这 里，该目录下可新建页面目录。<ul>
<li>_drafts：草稿文章</li>
<li>_posts：发布文章</li>
</ul>
</li>
<li>themes：主题文件目录</li>
<li>_config.yml：全局配置文件，大多数的设置都在这里</li>
<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>
</ul>
<h1 id="Hexo上传README文件"><a href="#Hexo上传README文件" class="headerlink" title="Hexo上传README文件"></a>Hexo上传README文件</h1><p>Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。</p>
<p>Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？</p>
<p>在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。</p>
<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install &lt;plugin-name&gt; --save # 安装插件</div><div class="line">npm update                       # 升级插件</div><div class="line">npm uninstall &lt;plugin-name&gt;      # 卸载插件</div></pre></td></tr></table></figure>
<p>hexo插件<a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="external">Plugins · hexojs/hexo</a></p>
<h2 id="RSS订阅插件"><a href="#RSS订阅插件" class="headerlink" title="RSS订阅插件"></a>RSS订阅插件</h2><p>以管理员运行命令行，进入hexo目录下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure></p>
<p>这个命令来自<a href="https://www.npmjs.com/package/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a><br>修改 Hexo 根目录下的 _config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">feed:</div><div class="line">       type: atom</div><div class="line">       path: atom.xml</div><div class="line">       limit: 20</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意格式，‘feed’不能缩进</p>
</blockquote>
<h2 id="Sitemap插件"><a href="#Sitemap插件" class="headerlink" title="Sitemap插件"></a>Sitemap插件</h2><blockquote>
<p>Sitemap 的提交主要的目的，是要避免搜索引擎的爬虫没有完整的收录整个网页的内容，所以提交 Sitemap<br>是能够补足搜索引擎的不足，进而加速网页的收录速度，达到搜寻引擎友好的目的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure>
<p>这个命令来自<a href="https://www.npmjs.com/package/hexo-generator-sitemap" target="_blank" rel="external">hexo-generator-sitemap</a><br>对于国内用户还需要安装插件 hexo-generator-baidu-sitemap<br>修改配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sitemap:</div><div class="line">       path: sitemap.xml</div><div class="line">baidusitemap:</div><div class="line">            path: baidusitemap.xml</div></pre></td></tr></table></figure></p>
<h1 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h1><p>简单易使用<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="external">不蒜子</a></p>
<h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><p>在Hexo中，默认使用的评论是国外的Disqus,但是Disqus只支持G+ twitter等登陆，我改为国内的<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>评论系统。<br>我使用next主题，hexo 版本为3.2.2，在<code>\hexo\themes\next\layout\_partial\comment.ejs</code>中自动配置多说评论框代码，只需在hexo根目录下的配置文件中加上<code>duoshuo_shortname: Kongwsh</code></p>
<h1 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h1><p>Github Pages提供制作404页面的教程：<a href="https://help.github.com/articles/creating-a-custom-404-page-for-your-github-pages-site/" target="_blank" rel="external">Creating a custom 404 page for your GitHub Pages site</a> 。不过 </p>
<blockquote>
<p>If you want your Project Pages site to have a custom 404 page, you must use a custom domain.</p>
</blockquote>
<p>直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。<br>404公益是个特别好的想法，目前有以下几个：</p>
<ul>
<li><a href="http://www.qq.com/404/" target="_blank" rel="external">腾讯公益404</a></li>
<li><a href="http://yibo.iyiyun.com/Index/web404" target="_blank" rel="external">404公益_益云(公益互联网)社会创新中心</a></li>
<li><a href="http://404page.missingkids.org.tw/" target="_blank" rel="external">失蹤兒童少年資料管理中心404</a></li>
</ul>
<h1 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h1><p>将favicon.ico放到工程根目录下即可，也就是hexo\source目录。可以在Faviconer制作你的ico图标，国内有<a href="http://www.bitbug.net/" target="_blank" rel="external">比特虫</a>。</p>
<h1 id="hexo更新"><a href="#hexo更新" class="headerlink" title="hexo更新"></a>hexo更新</h1><p>更新hexo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm update -g hexo</div></pre></td></tr></table></figure></p>
<p>更新主题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd themes/你的主题</div><div class="line">git pull</div></pre></td></tr></table></figure></p>
<p>更新插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm update</div></pre></td></tr></table></figure></p>
<h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><p>图床专门用来存放图片，同时允许把图片对外连接。</p>
<ul>
<li><a href="https://portal.qiniu.com/" target="_blank" rel="external">七牛</a></li>
<li><a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a></li>
<li><a href="http://yotuku.cn/" target="_blank" rel="external">yotuku</a> 我用的这个，免费的。</li>
<li><a href="http://www.tietuku.com/" target="_blank" rel="external">贴图库</a></li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>以下还没做</p>
<ul>
<li>绑定域名</li>
<li>分享</li>
<li>搜索</li>
<li>同步 Dropbox </li>
<li>将独立域名与GitHub Pages的空间绑定，官方教程：<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="external">Using a custom domain with GitHub Pages</a></li>
<li>迁移</li>
<li>CDN加速</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建Github Pages博客记录]]></title>
      <url>http://yoursite.com/2016/06/30/hexo-0/</url>
      <content type="html"><![CDATA[<h1 id="HEXO-简介"><a href="#HEXO-简介" class="headerlink" title="HEXO 简介"></a><strong>HEXO 简介</strong></h1><p>Hexo出自<em><a href="https://github.com/tommy351" target="_blank" rel="external">tommy351</a></em>之手，基于Node.js的静态博客程序，Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。<br>Hexo <em><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a></em></p>
<a id="more"></a>
<h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a><strong>安装前提</strong></h1><p>注意：系统：win8.1</p>
<ul>
<li>安装git<br>下载安装<em> <a href="https://git-scm.com/download/win" target="_blank" rel="external">git</a></em></li>
<li>安装node.js<br>简单安装方法，<em><a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a></em>下载.msi格式，默认安装会自动配置环境变量。</li>
</ul>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h1><p>使用npm命令即可直接安装 (可以直接在屏幕任意地方直接右键: Git Bash Here)<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo -g</div></pre></td></tr></table></figure></p>
<p>“g”表示全局安装,静候几分钟安装完成。</p>
<blockquote>
<p>注意要在管理员下运行命令行</p>
</blockquote>
<h1 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a><strong>部署Hexo</strong></h1><p>现在本地创建hexo文件夹（例如我的D:\HEXO），在哪都行，然后进入hexo目录，右键 Git Bash Here<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init</div></pre></td></tr></table></figure></p>
<p>Hexo 自动创建所需的文件<br>npm 安装依赖环境<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>ok了。</p>
<h1 id="运行Hexo"><a href="#运行Hexo" class="headerlink" title="运行Hexo"></a><strong>运行Hexo</strong></h1><p>现在在D:\HEXO内右键<em>Git Bash Here</em> 输入以下命令<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<p>运行成功的界面<br><img src="http://i2.piimg.com/567571/efef15c89c1f71e8.png" alt="Alt text"><br>访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 查看效果<br><img src="http://i1.piimg.com/567571/420c06e6efb72f6d.png" alt="效果图"></p>
<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a><strong>Github</strong></h1><ul>
<li>注册github账号</li>
<li>添加SSH公钥</li>
<li>使用GitHub Pages建立博客</li>
</ul>
<p>注册完github账号，如何让本地git项目与远程的github建立联系呢，使用SSH key。</p>
<h2 id="检查SSH-Key"><a href="#检查SSH-Key" class="headerlink" title="检查SSH Key"></a>检查SSH Key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/.ssh</div></pre></td></tr></table></figure>
<p>提示“No such file or directory”代表咱是第一回用。</p>
<h2 id="生成新的SSH-Key"><a href="#生成新的SSH-Key" class="headerlink" title="生成新的SSH Key"></a>生成新的SSH Key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;you@youremail.com&quot;</div></pre></td></tr></table></figure>
<p>屏幕提示：Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):（回车）<br>Enter passphrase (empty for no passphrase):（回车）<br>Enter same passphrase again:（回车）<br>hexo 自动部署如果有密码就会失败。</p>
<h2 id="添加SSH-Key到GitHub"><a href="#添加SSH-Key到GitHub" class="headerlink" title="添加SSH Key到GitHub"></a>添加SSH Key到GitHub</h2><p>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/.ssh/ &amp;&amp; ls</div></pre></td></tr></table></figure></p>
<p>可以看到此目录下的文件：<code>id_rsa</code> <code>id_rsa.pub</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat id_rsa.pub</div></pre></td></tr></table></figure></p>
<p>把SSH key 复制下来<br><img src="http://i1.piimg.com/567571/e8bd1567403a0940.png" alt="3"><br>哈，登录自己的github账号 Settings —&gt; SSH and GPG keys—&gt; Add SSH keys <a href="https://github.com/settings/keys" target="_blank" rel="external">https://github.com/settings/keys</a><br><img src="http://i4.piimg.com/567571/8a8501d59a29c75d.png" alt="4"><br>测试一下有没有添加成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p> <code>Hi Kongwsh! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>说明已经配置成功。</p>
<h2 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Kongwsh&quot;//用户名</div><div class="line">$ git config --global user.email  &quot;echokws@163.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>
<p>本机已成功连接到github。</p>
<h2 id="使用GitHub-Pages建立博客"><a href="#使用GitHub-Pages建立博客" class="headerlink" title="使用GitHub Pages建立博客"></a>使用GitHub Pages建立博客</h2><p>Github Pages可以被认为是用户编写的、托管在github上的静态网页。点这里官方说明<a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p>
<p>GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。</p>
<p>想建立个人博客是用的第一种，形如Kongwsh.github.io这样的可访问的站，每个用户名下面只能建立一个。建立与名字一致的仓库名，格式为yourname.github.io。<br><img src="http://i1.piimg.com/567571/097549dcd2066599.png" alt="5"></p>
<h1 id="开始使用hexo"><a href="#开始使用hexo" class="headerlink" title="开始使用hexo"></a><strong>开始使用hexo</strong></h1><h2 id="hexo-命令"><a href="#hexo-命令" class="headerlink" title="hexo 命令"></a>hexo 命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;postName&quot; #新建文章</div><div class="line">hexo new page &quot;pageName&quot; #新建页面</div><div class="line">hexo generate #生成静态页面至public目录</div><div class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class="line">hexo deploy #将.deploy目录部署到GitHub</div><div class="line">hexo clean # 清理 database 和 /public目录， /public 目录里是生成的静态文件数据</div></pre></td></tr></table></figure>
<p>简写为：</p>
<blockquote>
<p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy</p>
</blockquote>
<p>组合命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo d -g #生成加部署 </div><div class="line">hexo s -g #预览加部署</div><div class="line">hexo s -debug #开启调试模式，观察命令行输出是否有异常，这些信息有助于定位错误</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。</p>
</blockquote>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>进入hexo目录，右键<em>Git Bash Here</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save ## 安装部署所需要的插件</div></pre></td></tr></table></figure></p>
<h2 id="克隆hexo主题"><a href="#克隆hexo主题" class="headerlink" title="克隆hexo主题"></a>克隆hexo主题</h2><p>初始化hexo时也会自动生成一个主题, Hexo还支持个性定制主题, 可以根据自己的喜好对主题进行修改, <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">更多主题</a> 可以在官网中找到。<br>以<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">next</a> 主题为例，Next主题<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">使用文档</a></p>
<h3 id="克隆主题"><a href="#克隆主题" class="headerlink" title="克隆主题"></a>克隆主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd your-hexo-site</div><div class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>打开站点根目录下配置文件_config.yml， 找到 theme 字段，并将其值更改为 next。</p>
<blockquote>
<p> theme: next</p>
</blockquote>
<p><strong>注意：</strong> 修改配置文件冒号后一定空一格，否则不起作用。<br>在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 </p>
<h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s -debug</div></pre></td></tr></table></figure>
<p>用浏览器访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>，检查站点是否正确运行。</p>
<h2 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h2><p>配置 Hexo目录 下的 _config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line">## Docs: https://hexo.io/docs/configuration.html</div><div class="line">## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"># Site</div><div class="line">title: Kongwsh           # 网站标题</div><div class="line">subtitle:                # 副标题</div><div class="line">description: Front-End   # 描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到</div><div class="line">author: Kong             # 网站作者</div><div class="line">language: zh-Hans        # 语言</div><div class="line">email: echokws@163.com   # 邮箱</div><div class="line">timezone: Asia/Hong_Kong # 时区</div><div class="line">avatar: /images/avatar.jpg # 头像</div><div class="line"></div><div class="line"></div><div class="line"># URL #域名和文件结构</div><div class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line">url: http://ibruce.info #你的域名</div><div class="line">root: /</div><div class="line">permalink: :year/:month/:day/:title/</div><div class="line">tag_dir: tags</div><div class="line">archive_dir: archives</div><div class="line">category_dir: categories</div><div class="line">code_dir: downloads/code</div><div class="line"></div><div class="line"># Writing #写文章选项</div><div class="line">new_post_name: :title.md # File name of new posts</div><div class="line">default_layout: post #默认layout方式</div><div class="line">auto_spacing: false # Add spaces between asian characters and western characters</div><div class="line">titlecase: false # Transform title into titlecase</div><div class="line">external_link: true # Open external links in new tab</div><div class="line">max_open_file: 100</div><div class="line">multi_thread: true</div><div class="line">filename_case: 0</div><div class="line">render_drafts: false</div><div class="line">highlight: #代码高亮</div><div class="line">  enable: true #是否启用</div><div class="line">  line_number: false #是否显示行号</div><div class="line">  tab_replace:</div><div class="line"></div><div class="line"># Category &amp; Tag #分类与标签</div><div class="line">default_category: uncategorized # default</div><div class="line">category_map:</div><div class="line">tag_map:</div><div class="line"></div><div class="line"># Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突</div><div class="line">## 2: Enable pagination</div><div class="line">## 1: Disable pagination</div><div class="line">## 0: Fully Disable</div><div class="line">archive: 1</div><div class="line">category: 1</div><div class="line">tag: 1</div><div class="line"></div><div class="line"># Server #本地服务参数</div><div class="line">## Hexo uses Connect as a server</div><div class="line">## You can customize the logger format as defined in</div><div class="line">## http://www.senchalabs.org/connect/logger.html</div><div class="line">port: 4000</div><div class="line">logger: true</div><div class="line">logger_format:</div><div class="line"></div><div class="line"># Date / Time format #日期显示格式</div><div class="line">## Hexo uses Moment.js to parse and display date</div><div class="line">## You can customize the date format as defined in</div><div class="line">## http://momentjs.com/docs/#/displaying/format/</div><div class="line">date_format: MMM D YYYY</div><div class="line">time_format: H:mm:ss</div><div class="line"></div><div class="line"># Pagination #分页设置</div><div class="line">## Set per_page to 0 to disable pagination</div><div class="line">per_page: 10 #每页10篇文章</div><div class="line">pagination_dir: page</div><div class="line"></div><div class="line"># Disqus #社会化评论disqus</div><div class="line">disqus_shortname:</div><div class="line"></div><div class="line"># Extensions #插件，暂时未安装插件</div><div class="line">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</div><div class="line">## Themes: https://github.com/tommy351/hexo/wiki/Themes</div><div class="line">## 主题</div><div class="line">theme: modernist # raytaylorism # pacman # modernist # light</div><div class="line">exclude_generator:</div><div class="line"></div><div class="line"></div><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy: </div><div class="line">  type: git   # 部署位置</div><div class="line">  repository: git@github.com:Kongwsh/Kongwsh.github.io.git</div><div class="line">  # 这里填写项目的地址 git@github.com:Git用户名/Git用户名.github.io.git 参照上面</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;postName&quot;  #新建博文,其中postName是博文题目</div></pre></td></tr></table></figure>
<p>执行命令后，会在项目\source_posts中生成postName.md文件，用编辑器打开编写即可。<a href="http://wowubuntu.com/markdown/index.html#blockquote" target="_blank" rel="external">Markdown语法说明</a><br>当然，也可以直接在\source_posts中新建一个md文件。<br>如果不想博文在首页全部显示, 并能出现 <code>阅读全文</code>按钮效果, 需要在你想在首页显示的部分下添加  <code>&lt;!--more--&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">此处及以上的内容会在首页显示</div><div class="line">&lt;!--more--&gt;</div><div class="line">一下是在首页隐藏的部分</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
  
  
</search>
